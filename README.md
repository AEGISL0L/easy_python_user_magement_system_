
# DB Migrations with Flask-Migrate


Example Workflow

Let's walk through an example of adding a new field to an existing model.
a. Modify the Model

In models.py, add a new field to your model:

python
''
class Usuario(db.Model):
    __tablename__ = 'usuario'
    id = db.Column(db.Integer, primary_key=True)
    nombre_usuario = db.Column(db.String(150), unique=True, nullable=False)
    contrase√±a = db.Column(db.String(150), nullable=False)
    rol = db.Column(db.String(50), nullable=False)
    # New field
    email = db.Column(db.String(120), unique=True, nullable=True)
''

b. Generate Migration Script

bash
''
flask db migrate -m "Add email field to Usuario model"
''
    Output: Alembic generates a migration script that adds the email column to the usuario table.

c. Review the Migration Script

Open the script and verify:

python
''
def upgrade():
    # ### commands auto generated by Alembic ###
    op.add_column('usuario', sa.Column('email', sa.String(length=120), nullable=True))
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic ###
    op.drop_column('usuario', 'email')
    # ### end Alembic commands ###
''

d. Apply the Migration

bash
''
flask db upgrade
''

e. Verify the Change

    Check the Database Schema: Use SQLite tools to confirm the new column exists.
    Test in Application: Update your application code to utilize the new field and ensure it works as expected.

9. Tips for Managing Migrations

a. Use Meaningful Migration Messages

When running flask db migrate -m "Message", use clear and descriptive messages to indicate what changes are included in the migration.

b. Keep Migrations Linear

Avoid branching migrations when possible. Ensure that the down_revision in each migration script points to the correct previous revision.

c. Clean Up Unused Migrations

If you have unused or experimental migrations, remove them to keep your migration history clean.
